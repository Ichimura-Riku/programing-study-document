# Python復習

## エラーの対処方法
- SyntaxError: 構文間違い（括弧、クオーテーション、コロンの数など）
- IndentationError: インデントのずれ
- ZeroDivisionError: 割り算で0で割ってしまった場合に発生
- UnicodeError: パス内の"\"がエスケープシーケンスとしてみなされて発生
- IndexError: リストやタプルで範囲外のindexを指定
- NameError: 定義していない名前の変数や関数を使った場合
- TypeError: 引数の不一致、データ型の不一致など

基本的にはエラーの文章をググって欲しいのですが、基本的なSyntaxErrorやIndexErrorなどはどういったエラーなのか覚えましょう（やってれば覚えます）。

エラーの対処には、コピペ検索と、エラー箇所参照の2つで出来ます。
エラー箇所の参照は、エラー文章のどこかに発生している行数や、エラーを起こしている文を教えてくれていると思うので、それを頼りにコードをたどってみてください。

## print()
print()を復習するのかよと思いましたか？実は最も大事な関数といっても過言ではありません。プログラムの出力としてはもちろん、コードのデバッグとしても非常に有用です。もし、デバッグ機能がないエディターを使っているのであれば、自分のコードが合っているか、随時確認していきましょう。

## コメントアウト
コメント機能もコーディングを進めるうえで重要な枠割を持っています。
- 一時削除
- 機能の説明やメモ

基本的にはこの2つが目的としてあります。
一時削除: 違うなと感じたコードや別の書きかたを試してみたいとき、完全に消してしまうのではなくコメントアウトすることで元のコードをすぐに復活させることができます。

機能の説明やメモ: 共同開発や引継ぎの時に他の人がすぐに機能を確認できるようにするため、コメントアウトで説明をすることもよくあります。また、個人開発でも長期間での開発であれば自分でさえなんの処理なのかもわからなくなることがあります。他人のためでなく、自分の脳内の整理という意味でも有効です。

VSCを利用している人はctrl + / で1行をコメントアウトできます。これは何度も使うことがあるので是非覚えてください。

## 変数
変数は値を入れる箱とよく例えられます。
変数の名前はよく議論になりますが、特に共同開発の場面ではコメントアウトの機能の説明と同様、一目でどんな変数なのかが分かるような名前を付けるのがいいです。すぐ理解できて誤解のないほどいい変数名となります。
```
[変数名] = [値]
```


## データ型

Pythonは様々なデータを扱うことができます。その基本型が4つあります。

|データ型|説明|具体例|
|---|---|---|
|int|整数|1, -4, 0|
|float|浮動小数点|3.14, 44.5|
|str|文字列|"のっティ", 'central'|
|bool|論理値|True, False|

#### 型を変換(キャスト)する

テキストファイルからデータを読み取ったりすると、数値でも文字列として認識されてしまいます。

そのような時は`a = int("2")`とすると、`a`には数値の`2`が格納されます。


## 算術演算子

演算子を使うことで様々な計算ができます。

|演算子|役割|具体例|結果|
|---|---|---|---|
|+|足し算|2 + 3|5|
|-|引き算|12 - 6|6|
|*|掛け算|5 * 3|15|
|/|割り算|5 / 2|2.5|
|%|余り|5 % 2|1|
|//|切り捨て割り算|5 // 2|2|
|**|累乗|2 ** 4|16|

## ここまでの確認問題
```

# (1) '春休み勉強会'と出力する
# (2) (1)の処理をコメントアウトしてみる
# (3) 123に対して4を和差積商
# (4) 123にの上2桁の取得と下2桁を取得(//,%で出来るよ)
```


## コレクション

コレクションとは、

### リスト(list)

リストは、要素をカンマ(,)で区切り、全体を[]で囲って作成します。
要素は数値、少数、文字列、論理値なんでもOK
``` python
scores = [91, 69, 77, 84, 100, 79]
routes = ["中央ルート", "南部ルート", "西部ルート", "北部ルート", "のんキールート"]
```
**値の参照**

値を参照するには、リストの変数名の後ろに[]を付け、中に番号を入れます。
この番号をインデックス、もしくは添え字といいます。

インデックスは一番左を`0`とし、右に行くにつれて増えていきます。
マイナスを指定すると、一番右を`-1`として左に行くにつれて減っていきます。
配列の範囲外に出てしまうと、エラー(IndexError)となります。

``` python
print(routes[1])
# "南部ルート"
print(scores[2 * -1])
# 100
print(scores[1*100])
# Error
```
#### スライス(おまけ)

リストの**特定の範囲**を参照したい時に使います。
整数と`:`を使って表します。

**開始点**`:`**終了点**`:`**飛ばす個数**

``` python
array = [0,1,2,3,4,5,6,7,8,9]
print(array[:])
# 0 1 2 3 4 5 6 7 8 9
print(array[5:])
# 5 6 7 8 9
print(array[:5])
# 0 1 2 3 4
print(array[0:8:2])
# 0 2 4 6
print(array[::2])
# 0 2 4 6
```

**値の追加**

リストには、新たに値を追加することができます。

追加するときには`.append()`もしくは`.insert()`という**メソッド**を使います。
メソッドとは、特定のオブジェクト(今回はリスト)のみで使える関数です。

このリストに対して操作を行う、ということが明確に示されています。

`.append(追加する値)`末尾に値を追加します。

`.insert(インデックス, 追加する値)`指定したインデックスに値を追加します。割り込むようなイメージ

``` python
fruits = ["りんご", "ばなな"]
fruits.append("ぶどう")
print(fruits)
# ["りんご", "ばなな", "ぶどう"]
fruits.insert(1, "いちご")
print(fruits)
# ["りんご", "いちご", "ばなな", "ぶどう"]
```

**値の変更**
リストは、中の値を変更することができます。
代入式を使います。
``` python
array = [0,1,2,3,4,5,6,7,8,9]
print(array[1])
# 1
array[1] = 100
print(array[1])
# 100
```
<br>

### タプル(tuple)
タプルは書き換えることができないリストです。
そのため、`.append()`や`.insert()`などの処理は使えません。

「リストと比べると不便」と思うかもしれませんが、そうではありません。
- できることが限られる分、消費メモリが少ない。
- 誤って値を書き換えてしまうことを防げる。

というメリットが挙げられます。

記述形式はリストと似ていますが、`[]`の代わりに`()`で囲みます。

値の参照はリスト同様、[添え字]を使って参照します

<br>

### ディクショナリ(dict)
ディクショナリは、その名の通り辞書のような機能を提供します。

「key」と「value」のペアを作り、「key」を使って「value」を参照します。
keyの値を`""`で囲み、valueを`:`の後ろに記述し、全体を`{}`で囲みます。

**値の参照**
ディクショナリには順番がありません。
そのため添え字を使って参照することはできません。
代わりに、[key]を使って参照します。

``` python
scores = {
    "math" : 76,
    "english": 91,
    "science": 68
}
print(scores["math"])
# 76
```

### セット(set)

セットは、集合を表します。
大きな2つの特徴があります。
- 重複(同じ値)がない
- 順番を持たない

記述はリストやタプルのように要素を`,`で区切って表し、`{}`で囲みます。

```python
A = { 1, 2, 3 }
B = { 3, 4, 5 }

print(A | B)    # 和集合
# { 1, 2, 3, 4, 5}
print(A | B)    # 積集合
# { 1, 2, 3, 4, 5}
print(A | B)    # 差集合
# { 1, 2, 3, 4, 5}
print(A | B)    # 排他的論理和集合
# { 1, 2, 3, 4, 5}
```

## 確認問題
```

```



## 条件分岐
#### 比較演算
これらの演算は全てbool型を返します。
|演算子|説明|
|---|---|
|<|右が左より大きい時に真|
|<=|右が左以上の時に真|
|>|右が左より小さい時に真|
|>=|右が左以下の時に真|
|==|同じ値の時に真|
|or|どちらかが真なら真|
|and|どちらも真なら真|
|in|左の要素が右にあるなら真|

#### if文
```
if [比較演算１] :
--->  比較演算１を満たすときの処理
    |
    v
elif [比較演算２] :
--->  比較演算１を満たさず、比較演算２を満たすときの処理
    |
    v
else:
--->  全ての比較演算を満たさないときの処理
    |
    v
```

## 繰り返し構文
#### for文
```
for [変数] in [イテラブルな要素]:
---> 繰り返す処理
    |
    v
```
for文は繰り返す処理の数が決まっているときに使うことが多いです。その中でもトップクラスに多いのはlistの処理です。listは、同じ処理がしたい値でまとめられていることがほとんどです。[イテラブルな要素]の部分に配列をそのまま入れれば、添え字で指定しなくても変数に各要素が順番に取り出して処理を進めることができます。
また、シンプルなfor文の使い方をするにはrange()関数を用います。
他言語のfor文は
```
for( 変数定義 ＋ 開始の値を指定; 繰り返す範囲の指定; 値の変化量 )
```
という記法が多いですが、同じような繰返し範囲の指定ができます。
```
for [変数] in range( 開始の値を指定, 終了の値を指定, 値の変化量):
```
このように記述することで、[変数]に指定の順番で数値が入り、添え字にしたり、シンプルにやりたい繰り返し処理の回数を指定することができます。
range()は引数を省略することもできます。
|記法|意味|
|---|---|
|range(a)|0 ~ a-1まで繰り返す|
|range(a, b)|a ~ b-1まで繰り返す|
|range(a, b, c)|a ~ b-1までcずつ増やして繰り返す|


#### while文
```
while [boolの値] :
--->  繰り返す処理
    |
    v
```
while文は繰り返す回数が分からないときや、完全に無限ループにしてしまうときに使うことが多いです。
[boolの値]には、比較演算子を用いた式を入れるパターンと、そのままTrueを入れるパターンがあります。
比較演算子を使うパターンは事前に変数を定義しておき、boolの値として比較演算子を使って記述します。繰り返しの中でその変数が変化するように記述する必要があります。
Trueをそのまま入れるパターンでは、繰り返し処理の中で条件分岐を入れてbreakで抜けることが多いです。

#### ループ中断
ループの中断をするにはbreakとcontinueがあります。
break: 繰り返し処理を中断し、繰り返し文を抜け出す
continue: 繰り返し処理を中断し、次の繰り返し処理に進む

二重ループにすると特にややこしくなります。気をつけましょう。

## 確認問題
```
# (1)[1, 2, 3, 4]という配列に対して、偶数を文字列型に変換して配列を出力
# (2)0より小さい数を入力するまで数字が入力されたら加算し、その値を出力
```

## 関数
何らかの処理をまとめたものを関数といいます。

関数を使うメリットは次の3つです。
- コードの可読性向上
- コードの重複を減らせる
- 中身を見ずとも全体の処理を理解することができる

関数がどのような処理をしているのか、分かりやすい名前をつけることでより関数のメリットを向上させることができます。
```
def [関数名] ([引数]):
--->  関数の処理
    |
    v return [戻り値]
```
関数の入力値を「引数」といい、returnで返される値を「戻り値（返り値）」といいます。
引数や戻り値は指定しなくてはいけないというものではありません。必要に応じて使い分けましょう


#### ローカルな値、グローバルな値
引数は数値型や文字列型の変数であれば呼び出し元の変数に影響がありません。配列を呼び出した場合は呼び出し元の配列に影響を及ぼします。変数も配列同様に影響を及ぼす要素にするにはglobalをつけて宣言します。逆に影響を及ぼさない配列にする場合はcopy()を使います。
```
# 関数内で変数が、呼び出し元に影響を与える動作と与えない動作の比較
a = 1                       #aに影響なし
b = 2                       #bに影響なし
c = 3                       #cに影響あり
li1 = [0, 1, 2]             #li1に影響あり
li2 = li1.copy()            #li1に影響なし
li3 = [0, 1, 2]             #li3に影響あり

def func1(a, li1, li2):
    a = 10
    b = 20
    global c
    c = 30
    li1[0] = 10
    li2[0] = 20
    li3[0] = 30
    return a, b, c, li1, li2

# 関数実行前の値を確認
print(a, b, c, li1, li2, li3)  # 1 2 3 [0, 1, 2] [0, 1, 2] [0, 1, 2]
fa, fb, fc, fli1, fli2 = func1(a, li1, li2)

# 関数実行後の値を確認
print(a, b, c, li1, li2, li3)  # 1 2 30 [10, 1, 2] [20, 1, 2] [30, 1, 2]

# 関数の戻り値の確認
print(fa, fb, fc, fli1, fli2, li3) # 10 20 30 [10, 1, 2] [20, 1, 2] [30, 1, 2]
```
[ここから](https://pythontutor.com/python-debugger.html#mode=edit)挙動を確認しましょう
returnで複数の値を戻したいときはカンマ区切りで書くことでタプル型で値が戻ります。
先ほどのコードのように対応する数の変数を用意すればそれぞれに割り当てることができます。

おまけでスター演算子について紹介します。
```
a = 1
def func2(a):
    return a, a+1, a+2

# func2()は3つの戻り値がタプルで渡されている
print(func2(a))         # (1, 2, 3)

# 3つの戻り値に対して受け取る変数にスター演算子を使うと...
b, *c = func2(a) #b, c = 1, [2, 3]
print(b, c)             # 1 [2, 3]

# listやタプルに直接スター演算子を使うと...
print(*func2(a))        # 1 2 3

# 配列の代入、展開に便利！！

```
## インポート(import)
インポートすることでライブラリから便利な機能を使うことができます。
```
import [モジュール1], [モジュール2]
import [モジュール名] as [モジュール名の別名]
from [モジュール名] import [オブジェクト名]

# 使うとき
[モジュール].[オブジェクト名]
[モジュール].[メソッド名]()
```
この時点でオブジェクトが分からない人は、モジュールの中のさらに細かい機能をピンポイントで持ってきていると考えてOKです。
開発では頻繁に使う関係上、入り始めの時はimportのエラーが起こるときがあります。その場合は足りないライブラリを入れたり、バージョンを更新したりしましょう。

pythonの場合
インストールするとき

> pip insntall パッケージ名
更新するとき
> pip install --upgrade パッケージ名

## 確認問題
```
# (1)func1()があるコード例をpythonTutorかthonnyで実行してみよう
# 好きなモジュールを調べて使ってみよう
```


## memo

1.セットアップ、動作確認、勉強方法（調べる、言語化）、エラー対処、print関数、コメント
2.演算、四則演算
3.変数、変数の型、数値、（int、float）、文字列、型変換（キャスト）、標準入出力、input関数
4.コレクション（dict、tuple、set、list）
5.比較演算、if文（if、elif、else）＋練習＋コレクション
6.range関数、for文（for、continue、break）、for＋range
7.while、while無限ループ
8.インポート、問題練習
9.問題練習＋内包表現、map入力＋対話型確認
10～.練習