# Python復習 part2

[<< part1](./python1.md)

## 条件分岐
#### 比較演算
これらの演算は全てbool型を返します。
|演算子|説明|
|---|---|
|<|右が左より大きい時に真|
|<=|右が左以上の時に真|
|>|右が左より小さい時に真|
|>=|右が左以下の時に真|
|==|同じ値の時に真|
|or|どちらかが真なら真|
|and|どちらも真なら真|
|in|左の要素が右にあるなら真|

#### if文
``` python
if [比較演算１] :
--->  比較演算１を満たすときの処理
    |
    v
elif [比較演算２] :
--->  比較演算１を満たさず、比較演算２を満たすときの処理
    |
    v
else:
--->  全ての比較演算を満たさないときの処理
    |
    v
```

## 繰り返し構文
#### for文
``` py
for [変数] in [イテラブルな要素]:
---> 繰り返す処理
    |
    v
```
for文は繰り返す処理の数が決まっているときに使うことが多いです。その中でもトップクラスに多いのはlistの処理です。listは、同じ処理がしたい値でまとめられていることがほとんどです。[イテラブルな要素]の部分に配列をそのまま入れれば、添え字で指定しなくても変数に各要素が順番に取り出して処理を進めることができます。
また、シンプルなfor文の使い方をするにはrange()関数を用います。
他言語のfor文は
``` java
for( 変数定義 ＋ 開始の値を指定; 繰り返す範囲の指定; 値の変化量 )
```
という記法が多いですが、同じような繰返し範囲の指定ができます。
``` py
for [変数] in range( 開始の値を指定, 終了の値を指定, 値の変化量):
```
このように記述することで、[変数]に指定の順番で数値が入り、添え字にしたり、シンプルにやりたい繰り返し処理の回数を指定することができます。
range()は引数を省略することもできます。
|記法|意味|
|---|---|
|range(a)|0 ~ a-1まで繰り返す|
|range(a, b)|a ~ b-1まで繰り返す|
|range(a, b, c)|a ~ b-1までcずつ増やして繰り返す|


#### while文
```py
while [boolの値] :
--->  繰り返す処理
    |
    v
```
while文は繰り返す回数が分からないときや、完全に無限ループにしてしまうときに使うことが多いです。
[boolの値]には、比較演算子を用いた式を入れるパターンと、そのままTrueを入れるパターンがあります。
比較演算子を使うパターンは事前に変数を定義しておき、boolの値として比較演算子を使って記述します。繰り返しの中でその変数が変化するように記述する必要があります。
Trueをそのまま入れるパターンでは、繰り返し処理の中で条件分岐を入れてbreakで抜けることが多いです。

#### ループ中断
ループの中断をするにはbreakとcontinueがあります。
break: 繰り返し処理を中断し、繰り返し文を抜け出す
continue: 繰り返し処理を中断し、次の繰り返し処理に進む

二重ループにすると特にややこしくなります。気をつけましょう。

## 確認問題
[ここから](/Python/check/checkQ3.py)飛べます
``` python
# (1)[1, 2, 3, 4]という配列に対して、偶数を文字列型に変換して配列を出力
# (2)0より小さい数を入力するまで数字が入力されたら加算し、その値を出力
```

## 関数
何らかの処理をまとめたものを関数といいます。

関数を使うメリットは次の3つです。
- コードの可読性向上
- コードの重複を減らせる
- 中身を見ずとも全体の処理を理解することができる

関数がどのような処理をしているのか、分かりやすい名前をつけることでより関数のメリットを向上させることができます。
``` py
def [関数名] ([引数]):
--->  関数の処理
    |
    v return [戻り値]
```
関数の入力値を「引数」といい、returnで返される値を「戻り値（返り値）」といいます。
引数や戻り値は指定しなくてはいけないというものではありません。必要に応じて使い分けましょう


#### ローカルな値、グローバルな値
引数は数値型や文字列型の変数であれば呼び出し元の変数に影響がありません。配列を呼び出した場合は呼び出し元の配列に影響を及ぼします。変数も配列同様に影響を及ぼす要素にするにはglobalをつけて宣言します。逆に影響を及ぼさない配列にする場合はcopy()を使います。
```py
# 関数内で変数が、呼び出し元に影響を与える動作と与えない動作の比較
a = 1                       #aに影響なし
b = 2                       #bに影響なし
c = 3                       #cに影響あり
li1 = [0, 1, 2]             #li1に影響あり
li2 = li1.copy()            #li1に影響なし
li3 = [0, 1, 2]             #li3に影響あり

def func1(a, li1, li2):
    a = 10
    b = 20
    global c
    c = 30
    li1[0] = 10
    li2[0] = 20
    li3[0] = 30
    return a, b, c, li1, li2

# 関数実行前の値を確認
print(a, b, c, li1, li2, li3)  # 1 2 3 [0, 1, 2] [0, 1, 2] [0, 1, 2]
fa, fb, fc, fli1, fli2 = func1(a, li1, li2)

# 関数実行後の値を確認
print(a, b, c, li1, li2, li3)  # 1 2 30 [10, 1, 2] [20, 1, 2] [30, 1, 2]

# 関数の戻り値の確認
print(fa, fb, fc, fli1, fli2, li3) # 10 20 30 [10, 1, 2] [20, 1, 2] [30, 1, 2]
```
[ここから](https://pythontutor.com/python-debugger.html#mode=edit)挙動を確認しましょう
returnで複数の値を戻したいときはカンマ区切りで書くことでタプル型で値が戻ります。
先ほどのコードのように対応する数の変数を用意すればそれぞれに割り当てることができます。

おまけでスター演算子について紹介します。
```py
a = 1
def func2(a):
    return a, a+1, a+2

# func2()は3つの戻り値がタプルで渡されている
print(func2(a))         # (1, 2, 3)

# 3つの戻り値に対して受け取る変数にスター演算子を使うと...
b, *c = func2(a) #b, c = 1, [2, 3]
print(b, c)             # 1 [2, 3]

# listやタプルに直接スター演算子を使うと...
print(*func2(a))        # 1 2 3

# 配列の代入、展開に便利！！

```
## インポート(import)
インポートすることでライブラリから便利な機能を使うことができます。
```py
import [モジュール1], [モジュール2]
import [モジュール名] as [モジュール名の別名]
from [モジュール名] import [オブジェクト名]

# 使うとき
[モジュール].[オブジェクト名]
[モジュール].[メソッド名]()
```
この時点でオブジェクトが分からない人は、モジュールの中のさらに細かい機能をピンポイントで持ってきていると考えてOKです。
開発では頻繁に使う関係上、入り始めの時はimportのエラーが起こるときがあります。その場合は足りないライブラリを入れたり、バージョンを更新したりしましょう。

pythonの場合
インストールするとき

> pip insntall パッケージ名

更新するとき
> pip install --upgrade パッケージ名

## 確認問題
[ここから](/Python/check/checkQ4.py)飛べます
```py
# (1)func1()があるコード例をpythonTutorかthonnyで実行してみよう
# (2)好きなモジュールを調べて使ってみよう
```

[<< part1](./python1.md)
